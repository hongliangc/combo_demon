# 会话日志 - 2026-02-03

## 🎯 本次目标
- [x] 修复 dinosaur 不能移动的问题
- [x] 修复 dinosaur 不会追人的问题
- [x] 修复敌人追击后停在原地不再追击的问题
- [x] 修复敌人被攻击后眩晕结束无法恢复移动的问题
- [x] 修复敌人进入眩晕后还会漂移的问题

## 📝 完成内容

### 问题1: Dinosaur 不能移动

**问题描述**: dinosaur 敌人在场景中完全不移动，状态机看起来正常运行但没有实际移动效果。

**排查过程**:
1. 添加调试输出到 EnemyAnimationHandler，确认状态机正常运行（Idle ↔ Wander 正常切换）
2. 确认 velocity 被正确设置（50.0 速度）
3. 确认 AnimationTree 正常工作

**根本原因**: main.tscn 中的配置问题
1. 所有敌人的 position 都是 (0, 0)，导致它们堆叠在世界原点
2. Enemy 节点设置了 `wander_speed = 0.0`，覆盖了默认值，导致速度为零

**解决方案**: 修改 [main.tscn](../../Scenes/main.tscn)

```tscn
[node name="Enemy" parent="Enemies" instance=ExtResource("2_8gbba")]
position = Vector2(100, 50)
max_health = 100000
health = 100000
# 移除 wander_speed = 0.0，使用默认值 50.0

[node name="Enemy2" parent="Enemies" instance=ExtResource("2_8gbba")]
position = Vector2(150, -30)

[node name="Enemy3" parent="Enemies" instance=ExtResource("2_8gbba")]
position = Vector2(-100, 80)
```

---

### 问题2: Dinosaur 不会追人

**问题描述**: dinosaur 敌人在 Idle 和 Wander 之间切换，但不会追击玩家。

**排查过程**:
1. 添加调试输出到 BaseState.try_chase() 和 get_distance_to_target()
2. 发现敌人的 global_position 始终是 (0, 0)，而 Boss 的位置正确

**根本原因**: 与问题1相同 - main.tscn 中敌人位置未设置

**解决方案**: 同问题1的修复

---

### 问题3: 追击后停在原地不再追击

**问题描述**: 敌人成功 Chase → Attack 后，即使玩家离开攻击范围，敌人也永远停在 Attack 状态不会返回 Chase。

**排查过程**:
1. 添加状态转换日志到 BaseStateMachine._execute_transition()
2. 观察到状态转换序列: `Idle -> Wander -> Chase -> Attack`，之后再无转换
3. 添加调试输出到 AttackState.physics_process_state()
4. 发现 distance=79.5 > range=25.0，应该触发转换但没有

**根本原因**: AttackState 的 `can_be_interrupted = false` 阻止了状态转换

详细分析:
- AttackState 设置了 `can_be_interrupted = false`（见 [AttackState.gd:8](../../Core/StateMachine/CommonStates/AttackState.gd#L8)）
- ChaseState 和 AttackState 都是 `BEHAVIOR` 优先级
- 当 AttackState 调用 `transition_to(chase_state_name)` 时，状态机检查 `can_transition_to()`
- `can_transition_to()` 逻辑（见 [BaseState.gd:272-282](../../Core/StateMachine/BaseState.gd#L272-L282)）:
  ```gdscript
  func can_transition_to(new_state: BaseState) -> bool:
      # 高优先级总是可以打断低优先级
      if new_state.priority > priority:
          return true
      # 同优先级检查可打断性
      if new_state.priority == priority:
          return can_be_interrupted  # 这里返回 false!
      return false
  ```
- 由于两者都是 BEHAVIOR 优先级，且 `can_be_interrupted = false`，转换被拒绝

**解决方案**: 修改 [AttackState.gd](../../Core/StateMachine/CommonStates/AttackState.gd)

```gdscript
func _init():
    priority = StatePriority.BEHAVIOR
    can_be_interrupted = true  # 允许自身决定转换到其他行为状态
    animation_state = "attack"
```

**设计说明**:
- `can_be_interrupted = true` 允许 AttackState 根据自身逻辑（距离检查）决定何时转换
- 高优先级状态（如 StunState: CONTROL 优先级）仍然可以打断 AttackState
- 这是正确的设计：状态应该能够自主决定转换到同优先级的其他状态

---

### 问题4: 眩晕结束后无法恢复移动

**问题描述**: dinosaur 移动中被攻击后，播放 stun 动画后就不能再移动了，永远停在原地。

**排查过程**:
1. 添加状态转换日志
2. 发现 Stun 状态没有任何转换输出
3. 检查 `can_transition_to()` 逻辑

**根本原因**: `can_transition_to()` 的优先级逻辑有设计缺陷

详细分析:
- StunState 是 CONTROL 优先级 (2)
- WanderState/ChaseState 是 BEHAVIOR 优先级 (0)
- 当 StunState 想转换到 WanderState 时：
  ```gdscript
  # 旧逻辑
  func can_transition_to(new_state: BaseState) -> bool:
      if new_state.priority > priority:  # 0 > 2 = FALSE
          return true
      if new_state.priority == priority:  # 0 == 2 = FALSE
          return can_be_interrupted
      return false  # 返回 FALSE，转换被阻止！
  ```
- 高优先级状态无法转换到低优先级状态，即使是自愿结束

**解决方案**: 修改 [BaseState.gd:268-285](../../Core/StateMachine/BaseState.gd#L268-L285)

```gdscript
## 检查是否可以转换到目标状态
## 规则：
## 1. 高优先级总是可以打断低优先级（外部中断）
## 2. 同优先级检查当前状态的 can_be_interrupted
## 3. 当前状态可以主动转换到任意低优先级状态（自愿结束）
func can_transition_to(new_state: BaseState) -> bool:
    if not new_state:
        return false
    # 高优先级总是可以打断低优先级
    if new_state.priority > priority:
        return true
    # 同优先级检查可打断性
    if new_state.priority == priority:
        return can_be_interrupted
    # 当前状态可以主动转换到低优先级状态（自愿结束控制）
    return true  # 修复：允许高优先级状态主动结束
```

**设计说明**:
- 高优先级状态（如 Stun）应该能够自愿结束并转换到低优先级状态
- `can_be_interrupted` 只控制同优先级之间的转换
- 高优先级打断低优先级、高优先级主动结束都应该被允许

---

### 问题5: 眩晕时敌人漂移

**问题描述**: dinosaur 被攻击进入眩晕状态时，还会带着之前的移动速度漂移一段距离，应该立即停止。

**根本原因**: StunState.enter() 没有重置速度

**解决方案**: 修改 [StunState.gd](../../Core/StateMachine/CommonStates/StunState.gd)

```gdscript
func enter() -> void:
    start_timer(stun_duration)

    # 立即停止移动
    stop_movement()

    # 标记为眩晕状态
    if "stunned" in owner_node:
        owner_node.stunned = true

func physics_process_state(_delta: float) -> void:
    if owner_node is not CharacterBody2D:
        return

    var body = owner_node as CharacterBody2D

    # 眩晕期间保持静止（除非有击退效果正在应用）
    var has_knockback = body.velocity.length() > 10.0
    if not has_knockback:
        body.velocity = Vector2.ZERO

    body.move_and_slide()
```

---

## 🔧 修改文件列表

| 文件 | 修改内容 |
|------|----------|
| [main.tscn](../../Scenes/main.tscn) | 添加敌人位置，移除 wander_speed=0.0 覆盖 |
| [AttackState.gd](../../Core/StateMachine/CommonStates/AttackState.gd) | can_be_interrupted = true |
| [BaseState.gd](../../Core/StateMachine/BaseState.gd) | 修复 can_transition_to() 允许高优先级状态主动结束 |
| [StunState.gd](../../Core/StateMachine/CommonStates/StunState.gd) | enter() 调用 stop_movement()，physics 中保持速度为零 |
| [BaseStateMachine.gd](../../Core/StateMachine/BaseStateMachine.gd) | 状态转换日志改为 DebugConfig.debug() |

---

## 💡 经验总结

### 1. 场景配置检查清单
- [ ] 确认实例化节点的位置不是默认 (0, 0)
- [ ] 确认导出变量没有被意外覆盖为无效值（如 speed = 0）
- [ ] 使用 `.tscn` 文件检查实际配置值

### 2. 状态机优先级系统设计原则
- `can_be_interrupted` 应该控制**外部**是否能打断当前状态
- 状态**自身**调用 `transition_to()` 应该总是被允许
- 如果需要严格控制转换，考虑使用更高优先级或专门的转换条件

### 3. 调试技巧
- 使用 `Engine.get_physics_frames() % N == 0` 控制调试输出频率
- 状态转换日志格式: `[EntityName] FromState -> ToState`
- 调试完成后将 print() 改为 DebugConfig.debug() 保持代码整洁

---

## 📊 状态机转换验证

修复后的正常状态转换序列:
```
[Enemy] Idle -> Wander      # 随机游荡
[Enemy] Wander -> Idle      # 游荡结束
[Enemy] Wander -> Chase     # 发现玩家
[Enemy] Chase -> Attack     # 进入攻击范围
[Enemy] Attack -> Chase     # 玩家离开攻击范围 ✓ (之前被阻止)
[Enemy] Chase -> Attack     # 再次进入攻击范围
[Enemy] Chase -> Wander     # 玩家超出检测范围
```
