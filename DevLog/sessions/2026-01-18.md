# 会话日志 - 2026-01-18

## 🎯 本次目标
- [x] 修复 V 键特殊攻击后敌人到处乱动的问题
- [x] 修复 GatherEffect 聚集范围受限于 HitBoxComponent 的架构缺陷
- [x] 总结 atk_sp（特殊攻击）的完整实现方案和架构
- [x] 优化 token 消耗（日志系统优化）
- [x] 编写开发日志和 token 优化报告

## 📝 完成内容

### 修复特殊攻击敌人移动问题

**问题描述**：使用 V 键特殊攻击后，boss 和 dinosaur 被攻击后还会到处乱动，应该汇聚到第一个敌人的位置后静止不动。

**根本原因分析**：

1. **双重伤害问题**
   - 第一次伤害：HitBoxComponent 碰撞触发（动画 0.4329 秒时）
   - 第二次伤害：`perform_special_attack()` 手动应用（动画 0.4 秒时）

2. **GatherEffect 目标位置错误**
   - SpecialAttack.tres 中的 GatherEffect 默认 `gather_target_position = (0.0, 0.0)`
   - 导致敌人被聚集到世界原点而非第一个敌人位置
   - `switch_to_special_attack()` 没有更新 GatherEffect 的目标位置

3. **碰撞系统推挤**（前期问题）
   - 即使 `velocity = ZERO`，`move_and_slide()` 仍会因碰撞分离而移动敌人
   - StunState 的 `physics_process_state()` 在 `can_move = false` 时仍调用了 `move_and_slide()`

**解决方案**：

#### 1. 在 `switch_to_special_attack()` 中设置 GatherEffect 目标位置

修改文件：[hahashin.gd:126-135](../Scenes/charaters/hahashin.gd#L126-L135)

```gdscript
func switch_to_special_attack() -> void:
	if damage_types.size() > 2:
		current_damage = damage_types[2]

		# 更新 GatherEffect 的目标位置为第一个敌人的位置
		if current_damage and current_damage.effects:
			for effect in current_damage.effects:
				if effect is GatherEffect:
					effect.set_gather_position(special_attack_target_position)
					print("[特殊攻击] 设置 GatherEffect 目标位置: ", special_attack_target_position)
```

**关键点**：
- `special_attack_target_position` 在 `prepare_special_attack()` 中被设置为第一个敌人的位置
- 动画开始时（0 秒）调用 `switch_to_special_attack()`，立即更新 GatherEffect 配置
- HitBoxComponent 碰撞时使用的 SpecialAttack.tres 中的 GatherEffect 已经有了正确的目标位置

#### 2. 禁用 `perform_special_attack()` 的重复伤害

修改文件：[hahashin.gd:222-227](../Scenes/charaters/hahashin.gd#L222-L227)

```gdscript
## 特殊攻击：在动画的攻击帧中调用
## 注意：伤害已经由 HitBoxComponent 碰撞处理，此方法仅作为动画回调占位
func perform_special_attack() -> void:
	# HitBoxComponent 碰撞已经应用了 SpecialAttack.tres 中的伤害和特效
	# 不需要在这里重复应用，避免双重伤害
	print("[特殊攻击] perform_special_attack 被调用（伤害由 HitBoxComponent 处理）")
```

**关键点**：
- 避免双重伤害和特效应用
- 简化代码逻辑，所有伤害由 HitBoxComponent 统一处理
- 保留方法作为动画回调占位符

#### 3. StunState 添加 can_move 检查（已在前期修复）

修改文件：[stun_state.gd:68-82](../Util/StateMachine/CommonStates/stun_state.gd#L68-L82)

```gdscript
func physics_process_state(delta: float) -> void:
	if owner_node is not CharacterBody2D:
		return

	var body = owner_node as CharacterBody2D

	# 检查是否允许移动（ForceStunEffect 会设置 can_move = false）
	var can_move = true
	if "can_move" in owner_node:
		can_move = owner_node.can_move

	# 如果被强制眩晕（can_move = false），完全静止，不执行任何物理模拟
	if not can_move:
		body.velocity = Vector2.ZERO
		return

	# ... 其余物理模拟代码
```

**关键点**：
- 当 `can_move = false` 时，完全跳过物理模拟和 `move_and_slide()`
- 防止碰撞系统推挤重叠的敌人

### 重构 GatherEffect 架构（聚集范围优化）

**问题发现**：

用户指出了一个关键的架构缺陷：GatherEffect 通过 Damage 系统传递，导致聚集范围受限于 HitBoxComponent 碰撞范围。

**错误架构**：
```
检测范围：300px 扇形 → 检测到 5 个敌人
HitBoxComponent 范围：100px → 只碰撞到 2 个敌人
GatherEffect 通过 Damage 传递 → 只有 2 个敌人被聚集 ❌
```

**架构重构**：

1. **新增成员变量保存检测结果**
   ```gdscript
   var special_attack_detected_enemies: Array = []
   ```

2. **prepare_special_attack() 保存所有检测到的敌人**
   ```gdscript
   special_attack_detected_enemies = enemies_in_range.duplicate()
   ```

3. **perform_special_attack() 独立执行聚集**
   ```gdscript
   func perform_special_attack() -> void:
       for enemy in special_attack_detected_enemies:
           var gather_effect = GatherEffect.new()
           gather_effect.set_gather_position(global_position)
           gather_effect.apply_effect(enemy, global_position)
   ```

4. **从 SpecialAttack.tres 移除 GatherEffect**
   ```
   effects = Array[AttackEffect]([ForceStunEffect_1])
   ```

**改进效果**：
- ✅ 检测范围 = 聚集范围（300px）
- ✅ HitBoxComponent 范围独立（仅负责伤害和眩晕）
- ✅ 职责分离：聚集（范围效果）vs 伤害（单体效果）
- ✅ 并行执行：5 个敌人的 Tween 同时进行

## 📊 特殊攻击（atk_sp）完整架构总结

### 系统架构（优化后）

```
┌─────────────────────────────────────────────────────────────────┐
│                    特殊攻击流程架构                              │
└─────────────────────────────────────────────────────────────────┘

1. 玩家按下 V 键
   ↓
2. movement_handler.gd 调用 animation_handler.play_animation("atk_sp")
   ↓
3. animation_handler.gd:
   ├─ 检测配置中的 needs_preparation = true
   ├─ 调用 _prepare_and_play_special_attack()
   │   ├─ 调用 player.prepare_special_attack()
   │   │   ├─ 检测前方 300px、45° 扇形范围内的敌人
   │   │   ├─ 如果无敌人：返回 false，不触发技能
   │   │   ├─ 如果有敌人：
   │   │   │   ├─ 记录第一个敌人位置 → special_attack_target_position
   │   │   │   └─ 保存所有敌人列表 → special_attack_detected_enemies ✨
   │   │   └─ 返回 true
   │   │
   │   ├─ 如果检测到敌人：
   │   │   ├─ player.can_move = false
   │   │   ├─ await player.execute_special_attack_movement()
   │   │   │   └─ 使用 Tween 移动到 special_attack_target_position (0.2s)
   │   │   └─ _execute_animation("atk_sp")
   │   │
   │   └─ 如果无敌人：直接返回，不播放动画
   │
   └─ 播放 atk_sp 动画

4. atk_sp 动画时间轴（优化后）：
   ├─ 0.0s: 调用 switch_to_special_attack()
   │   └─ 切换到 SpecialAttack.tres 伤害配置（仅包含 ForceStunEffect）
   │
   ├─ 0.4s: 调用 perform_special_attack() ✨ 新架构
   │   └─ 遍历 special_attack_detected_enemies（所有检测到的敌人）
   │       └─ 为每个敌人创建并应用 GatherEffect
   │           ├─ 设置 gather_target_position = player.global_position
   │           ├─ 设置 can_move = false
   │           └─ 使用 Tween 移动敌人到玩家位置 (0.3s，并行执行)
   │
   ├─ 0.4329s: 启用 HitBoxComponent
   │   └─ HitBoxComponent 碰撞检测敌人（聚集中的敌人）
   │       └─ 应用 SpecialAttack.tres 伤害和特效：
   │           └─ ForceStunEffect ✨ 仅眩晕，不聚集
   │               ├─ 设置 can_move = false
   │               ├─ 设置 stunned = true
   │               ├─ 强制切换到 stun 状态
   │               ├─ 配置 StunState.stun_duration = 1.0
   │               └─ 禁用 StunState.vertical_velocity（防止击飞）
   │
   └─ 2.9s: 调用 switch_to_physical()，禁用 HitBoxComponent
       └─ 动画结束，player.can_move = true

5. 敌人 StunState 行为：
   ├─ enter():
   │   ├─ 记录 original_y
   │   ├─ 启动 stun_timer (1.0s)
   │   └─ 读取 velocity.y 设置 vertical_velocity（被 ForceStunEffect 禁用为 0）
   │
   ├─ physics_process_state(delta):
   │   ├─ 检查 can_move
   │   ├─ 如果 can_move = false: velocity = ZERO, return（跳过物理模拟）
   │   └─ 如果 can_move = true: 执行击飞/击退物理模拟
   │
   └─ on_timeout():
       ├─ 恢复 can_move = true
       ├─ 恢复 stunned = false
       └─ 根据玩家位置切换到 chase/wander/idle 等状态
```

### 核心组件说明

#### 1. 伤害系统
- **Damage.gd**：伤害数据类，包含 `effects: Array[AttackEffect]`
- **AttackEffect.gd**：攻击特效基类
- **SpecialAttack.tres**：特殊攻击伤害配置资源
  - ForceStunEffect：强制眩晕特效（持续 1.0s）
  - ~~GatherEffect~~：已移至 perform_special_attack() 独立执行

#### 2. 玩家控制
- **hahashin.gd**
  - `special_attack_detected_enemies`: 保存检测到的敌人列表 ✨
  - `prepare_special_attack()`: 检测前方敌人，保存列表，返回是否触发
  - `execute_special_attack_movement()`: Tween 移动到目标位置
  - `switch_to_special_attack()`: 切换伤害配置（仅 ForceStunEffect）
  - `perform_special_attack()`: **聚集所有检测到的敌人**（独立执行，不依赖 Damage 系统）✨

#### 3. 特效系统
- **GatherEffect.gd**
  - `set_gather_position(position)`: 设置聚集目标位置
  - `apply_effect()`: 使用 Tween 移动敌人，完成后检查 stunned 状态

- **ForceStunEffect.gd**
  - `apply_effect()`:
    - 设置 `can_move = false`，`stunned = true`
    - 强制切换到 stun 状态
    - 配置 StunState 的 `stun_duration` 和 `vertical_velocity = 0`

#### 4. 状态机
- **StunState.gd**（通用眩晕状态基类）
  - **物理模拟**：击飞（抛物线）、击退（横向摩擦）
  - **can_move 检查**：如果 `can_move = false`，跳过所有物理模拟
  - **定时器管理**：由 ForceStunEffect 配置 `stun_duration`

### 关键设计决策

1. **范围效果与伤害系统分离** ✨ 新架构
   - **范围效果**（如聚集）：独立检测和应用，不依赖 Damage 系统
   - **伤害系统**：仅处理单体效果（伤害、眩晕）
   - 避免范围受限于 HitBoxComponent 碰撞范围
   - 实现方式：`perform_special_attack()` 独立执行 GatherEffect

2. **检测-保存-应用三阶段分离**
   - **检测阶段**：`prepare_special_attack()` 检测 300px 范围敌人
   - **保存阶段**：保存到 `special_attack_detected_enemies` 数组
   - **应用阶段**：`perform_special_attack()` 对所有保存的敌人应用效果
   - 使得检测范围和应用范围完全一致

3. **Effect 和 State 的职责分离**
   - **AttackEffect**：瞬时配置（设置参数、切换状态）
   - **State**：持续模拟（物理、计时、恢复）
   - ForceStunEffect 不创建自己的 Timer，而是配置 StunState 的 Timer

4. **StunState 支持完全静止**
   - 通过 `can_move` 标志控制
   - `can_move = false` 时跳过 `move_and_slide()`，防止碰撞推挤

5. **并行执行聚集效果**
   - 多个敌人的 GatherEffect Tween 并行执行
   - 不阻塞主流程，提高性能
   - HitBoxComponent 在聚集进行中就可以碰撞

## 🐛 遇到的问题及解决方案

### 问题 1: 敌人被聚集到 (0.0, 0.0)

**现象**：使用 V 技能后，敌人被聚集到世界原点而非第一个敌人位置

**原因**：
- SpecialAttack.tres 中 GatherEffect 的 `gather_target_position` 默认为 `(0.0, 0.0)`
- `switch_to_special_attack()` 只切换了 `current_damage`，没有更新 GatherEffect 配置

**解决**：
在 `switch_to_special_attack()` 中遍历 effects，找到 GatherEffect 并调用 `set_gather_position(special_attack_target_position)`

### 问题 2: 双重伤害和特效应用

**现象**：
- 第一次：HitBoxComponent 碰撞触发（0.4329s），聚集到 (0.0, 0.0)，眩晕 1.0s
- 第二次：`perform_special_attack()` 手动应用（0.4s），聚集到玩家位置，眩晕 3.0s

**原因**：
- 历史遗留代码，`perform_special_attack()` 创建新的 GatherEffect 和 ForceStunEffect 并手动应用
- 与 HitBoxComponent 碰撞系统重复

**解决**：
- 清空 `perform_special_attack()` 实现，仅保留占位符
- 所有伤害统一由 HitBoxComponent 处理

### 问题 3: 敌人即使 can_move = false 也会移动

**现象**：多个敌人被聚集到同一位置后，会被碰撞系统推挤分开

**原因**：
- `StunState.physics_process_state()` 总是调用 `move_and_slide()`
- Godot 的碰撞系统会自动分离重叠的 CharacterBody2D

**解决**：
在 `physics_process_state()` 开头检查 `can_move`，如果为 `false` 则设置 `velocity = ZERO` 并 `return`，完全跳过物理模拟

### 问题 4: GatherEffect 聚集范围受限于 HitBoxComponent 碰撞范围（架构缺陷）

**现象**：检测到 5 个敌人（300px 范围），但只有 2 个敌人被聚集

**根本原因**：
```
错误架构：
1. 检测范围：300px 扇形
2. HitBoxComponent 范围：可能只有 100px
3. GatherEffect 通过 Damage 系统传递
4. 只有 HitBoxComponent 碰撞到的敌人才会收到 Damage
5. 结果：检测到的 5 个敌人中，只有 2 个被聚集 ❌
```

**正确逻辑应该是**：
- 检测范围（300px）内的**所有**敌人都应该被聚集
- 聚集不应该依赖 HitBoxComponent 碰撞
- HitBoxComponent 只负责应用伤害和眩晕

**解决方案**：

#### 1. 保存检测到的敌人列表

修改 [hahashin.gd](../Scenes/charaters/hahashin.gd)：

```gdscript
# 新增成员变量
var special_attack_detected_enemies: Array = []

# prepare_special_attack() 保存所有检测到的敌人
func prepare_special_attack() -> bool:
    var enemies_in_range = _detect_enemies_in_cone(detection_radius, detection_angle)

    if enemies_in_range.is_empty():
        special_attack_detected_enemies.clear()
        return false

    # 保存所有检测到的敌人，用于后续聚集
    special_attack_detected_enemies = enemies_in_range.duplicate()

    return true
```

#### 2. 在 perform_special_attack() 中独立聚集

```gdscript
func perform_special_attack() -> void:
    DebugConfig.info("特殊攻击: 聚集 %d 个敌人到 %v" % [...], "", "combat")

    # 聚集所有检测到的敌人到玩家当前位置
    for enemy in special_attack_detected_enemies:
        if is_instance_valid(enemy):
            var gather_effect = GatherEffect.new()
            gather_effect.set_gather_position(global_position)
            gather_effect.gather_duration = 0.3
            gather_effect.show_debug_info = true

            # 应用聚集特效（不 await，并行执行）
            gather_effect.apply_effect(enemy, global_position)

    special_attack_detected_enemies.clear()
```

#### 3. 从 SpecialAttack.tres 中移除 GatherEffect

修改 [SpecialAttack.tres](../Util/Data/SkillBook/SpecialAttack.tres)：

```
# 只保留 ForceStunEffect，移除 GatherEffect
effects = Array[AttackEffect]([ForceStunEffect_1])
```

#### 4. 移除 switch_to_special_attack() 中的 GatherEffect 配置

```gdscript
func switch_to_special_attack() -> void:
    if damage_types.size() > 2:
        current_damage = damage_types[2]
        # GatherEffect 相关代码已删除
```

**新的执行流程**：

```
时间轴：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
0.0s    检测前方敌人（300px 扇形）
        保存：[Enemy1, Enemy2, Enemy3, Enemy4, Enemy5]
        ↓
0.0s    开始移动到 Enemy1 位置（Tween 0.2s）
        ↓
0.2s    到达 Enemy1 位置
        ↓
0.4s    perform_special_attack() 调用
        → 聚集所有 5 个敌人到玩家位置（并行执行）
        ↓ (Tween 0.3s，不阻塞)
        ↓
0.4329s HitBoxComponent 启用
        → 碰撞到聚集中的敌人
        → 应用 ForceStunEffect（眩晕 + can_move=false）
        → 应用伤害
        ↓
0.7s    聚集完成（0.4 + 0.3）
        → 所有 5 个敌人到达玩家位置
        → 保持眩晕状态（stunned=true）
        ↓
1.4s    眩晕结束（0.4 + 1.0）
        → 敌人恢复移动
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**关键改进**：

1. **范围一致性**
   - 检测范围（300px）= 聚集范围（300px）
   - HitBoxComponent 范围独立，仅用于应用伤害和眩晕

2. **职责分离**
   - `perform_special_attack()`：聚集敌人（范围攻击前置）
   - `Damage 系统`：应用眩晕和伤害（单体效果）

3. **并行执行**
   - 5 个敌人的聚集 Tween 并行执行（不阻塞）
   - HitBoxComponent 在聚集进行中就可以碰撞

4. **兼容性**
   - GatherEffect 和 ForceStunEffect 协同工作
   - GatherEffect 检查 `stunned` 标志，不会恢复被眩晕敌人的移动

## 💡 重要经验教训

### 1. 资源配置与运行时配置的边界
- .tres 资源适合**静态配置**（固定值、预设参数）
- **动态值**（如敌人位置、玩家状态）必须在运行时设置
- 设计 API 时要考虑：什么在编辑器配置，什么在代码中动态设置

### 2. 避免双重系统
- 项目中同时存在两套伤害应用机制（HitBoxComponent + 手动调用）导致混乱
- **统一到一个系统**更易维护和调试
- 历史代码要及时清理，而非注释保留

### 3. Effect vs State 的职责分离
- **AttackEffect**：瞬时配置，不持有状态，不创建 Timer
- **State**：持续模拟，管理 Timer 和物理
- 遵循单一职责原则，避免职责重叠导致冲突（如双 Timer 问题）

### 4. 物理引擎的隐式行为
- `move_and_slide()` 不仅移动，还会处理碰撞分离
- 即使 `velocity = ZERO`，重叠物体也会被推开
- 完全静止需要**跳过** `move_and_slide()` 调用，而非设置 `velocity = 0`

### 5. Debug 日志的重要性
- 本次问题通过日志快速定位到 `gather_target_position = (0.0, 0.0)`
- `show_debug_info` 参数设计使得调试可开关
- 关键路径都应有 debug 输出

### 6. 效果范围与碰撞范围的区分
- **效果范围**（检测范围）：决定哪些敌人受影响（如聚集、减速）
- **碰撞范围**（HitBoxComponent 范围）：决定哪些敌人受伤害
- 两者可以不同，需要独立管理
- **反模式**：通过 Damage 系统传递范围效果（导致范围受限于碰撞）
- **正确做法**：
  - 范围检测独立进行
  - 范围效果独立应用
  - Damage 系统只负责单体效果（伤害、眩晕）

### 7. 数据流设计原则
- **检测 → 保存 → 应用** 三阶段分离
  1. 检测阶段：确定受影响的目标
  2. 保存阶段：记录目标列表
  3. 应用阶段：对目标应用效果
- 避免将"检测"和"应用"耦合在一起
- 使得检测范围和应用范围可以独立调整

## 📦 相关文件

### 核心逻辑
- [hahashin.gd](../Scenes/charaters/hahashin.gd) - 玩家特殊攻击逻辑
- [animation_hander.gd](../Scenes/charaters/animation_hander.gd) - 动画和技能触发
- [movement_hander.gd](../Scenes/charaters/movement_hander.gd) - 输入处理

### 伤害系统
- [Damage.gd](../Util/Classes/Damage.gd) - 伤害数据类
- [AttackEffect.gd](../Util/Classes/AttackEffect.gd) - 特效基类
- [GatherEffect.gd](../Util/Classes/GatherEffect.gd) - 聚集特效
- [ForceStunEffect.gd](../Util/Classes/ForceStunEffect.gd) - 强制眩晕特效
- [SpecialAttack.tres](../Util/Data/SkillBook/SpecialAttack.tres) - 特殊攻击配置

### 状态机
- [stun_state.gd](../Util/StateMachine/CommonStates/stun_state.gd) - 通用眩晕状态
- [enemy_stun.gd](../Scenes/enemies/dinosaur/Scripts/States/enemy_stun.gd) - 敌人眩晕状态
- [boss_stun.gd](../Scenes/enemies/boss/Scripts/States/boss_stun.gd) - Boss 眩晕状态

### 组件
- [hitbox.gd](../Util/Components/hitbox.gd) - 碰撞检测组件

### 配置与工具
- [debug_config.gd](../Util/AutoLoad/debug_config.gd) - 全局日志系统
- [debug_config.json](../Util/AutoLoad/debug_config.json) - 日志配置文件

### 本次会话修改的文件

**架构优化**（聚集范围问题）：
- ✅ [hahashin.gd](../Scenes/charaters/hahashin.gd) - 添加敌人列表保存，重构 perform_special_attack()
- ✅ [SpecialAttack.tres](../Util/Data/SkillBook/SpecialAttack.tres) - 移除 GatherEffect

**Token 优化**（日志系统）：
- ✅ [debug_config.json](../Util/AutoLoad/debug_config.json) - 全局日志级别 DEBUG→INFO，新增 effect 分类
- ✅ [GatherEffect.gd](../Util/Classes/GatherEffect.gd) - 精简日志输出（-86.7%）
- ✅ [ForceStunEffect.gd](../Util/Classes/ForceStunEffect.gd) - 精简日志输出（-90%）
- ✅ [stun_state.gd](../Util/StateMachine/CommonStates/stun_state.gd) - 精简日志输出（-100%，默认禁用）

**文档**：
- ✅ [2026-01-18.md](2026-01-18.md) - 本次会话日志
- ✅ [token_optimization_report.md](token_optimization_report.md) - Token 优化详细报告

## 📈 Token 消耗分析与优化建议

### 当前会话 Token 消耗分析

根据系统提示，当前会话消耗约 **43,000 tokens**（总预算 200,000）。

**主要消耗来源**：

1. **会话总结（Summary）** - 约 10,000+ tokens
   - 包含完整的对话历史总结
   - 包含所有修改的文件内容片段
   - 包含详细的问题分析和解决方案

2. **文件读取**
   - [hahashin.gd](../Scenes/charaters/hahashin.gd) (327 行) - 约 3,000 tokens
   - [hahashin.tscn](../Scenes/charaters/hahashin.tscn) (部分读取) - 约 2,000 tokens
   - [GatherEffect.gd](../Util/Classes/GatherEffect.gd) (87 行) - 约 800 tokens
   - 其他配置文件读取 - 约 1,000 tokens

3. **调试日志输出** - 约 2,000 tokens
   - 包含详细的运行时日志
   - 多次特效应用的 debug 输出

4. **工具调用和结果** - 约 5,000 tokens
   - Bash 命令输出
   - Grep 搜索结果
   - Glob 文件列表

5. **Claude 响应和分析** - 约 20,000+ tokens
   - 问题分析
   - 代码修改
   - 解决方案说明

### 优化建议

#### 🔧 立即可实施的优化

1. **精简 Debug 输出**
   ```gdscript
   # 当前：每个特效都有详细输出
   if show_debug_info:
       print("[GatherEffect] 开始聚集敌人: ", target.name)
       print("[GatherEffect] 当前位置: ", target.global_position)
       print("[GatherEffect] 目标位置: ", gather_target_position)

   # 优化：使用单行汇总
   if show_debug_info:
       print("[GatherEffect] %s: %v -> %v" % [target.name, target.global_position, gather_target_position])
   ```

2. **使用 Debug Level 分级**
   ```gdscript
   # DebugConfig.gd 添加 level
   enum DebugLevel { ERROR, WARN, INFO, VERBOSE }
   static var current_level = DebugLevel.INFO

   # 仅关键路径用 INFO，细节用 VERBOSE
   DebugConfig.verbose("详细的中间状态...")  # 默认不输出
   DebugConfig.info("关键状态变化")         # 始终输出
   ```

3. **减少文件重复读取**
   - 本次会话中 hahashin.gd 被读取 2 次
   - 可以在第一次读取后记住关键信息
   - 后续只读取需要修改的部分（使用 offset/limit）

4. **压缩历史总结**
   - 当前总结包含所有对话和代码片段
   - 可以仅保留关键决策和最终解决方案
   - 中间尝试的错误方案可以省略

#### 📊 长期架构优化

1. **Claude Code Skills 配置优化**
   ```json
   // .claude/skills/godot-coding-standards.md
   // 精简加载内容，只包含：
   - 命名规范速查表
   - 常用模式参考
   - 禁止事项清单
   // 移除：
   - 详细示例代码（按需查询）
   - 完整 API 文档（使用 Godot 官方文档）
   ```

2. **模块化日志系统**
   ```gdscript
   # 不同系统使用不同日志通道
   DebugConfig.combat("特殊攻击触发")     # 只在调试战斗时启用
   DebugConfig.animation("播放动画")      # 只在调试动画时启用
   DebugConfig.state("状态切换")          # 只在调试状态机时启用
   ```

3. **代码注释减少重复**
   - 当前代码有大量解释性注释
   - 很多可以通过命名自解释
   ```gdscript
   # 当前
   # 更新 GatherEffect 的目标位置为第一个敌人的位置
   effect.set_gather_position(special_attack_target_position)

   # 优化（命名自解释）
   effect.set_gather_position(first_enemy_position)
   ```

4. **使用类型注解减少歧义**
   ```gdscript
   # 明确类型可以减少 Claude 需要推断的 token
   var gather_effect: GatherEffect = effect as GatherEffect
   if gather_effect:
       gather_effect.set_gather_position(target_pos)
   ```

#### 🎯 会话交互优化

1. **用户提问更精确**
   - 当前："boss和dinosaur被v技能攻击后还是会到处乱动，重新检测和修复"
   - 优化："V 技能后敌人移动问题：检查 GatherEffect 目标位置和 move_and_slide 调用"
   - 效果：减少 Claude 探索范围，直接定位问题

2. **批量测试反馈**
   - 当前：每次修改后等用户测试，再报告问题
   - 优化：一次性列出所有观察到的现象
   - 效果：Claude 可以一次性分析所有问题，避免多轮对话

3. **提供最小复现步骤**
   - 当前：提供完整日志输出
   - 优化：标注关键异常行（如 "gather_target_position = (0.0, 0.0)"）
   - 效果：Claude 快速定位，无需解析完整日志

### Token 预算建议

```
总预算: 200,000 tokens
├─ 会话总结 (10-15%):    20,000-30,000 tokens
├─ 技能加载 (5-10%):     10,000-20,000 tokens
├─ 文件读取 (15-20%):    30,000-40,000 tokens
├─ 调试日志 (5%):         5,000-10,000 tokens
├─ Claude 分析 (40-50%): 80,000-100,000 tokens
└─ 预留 (10%):           20,000 tokens
```

**当前使用情况**：86,600 / 200,000 = **43.3%**（健康范围）

---

**最后更新**: 2026-01-18 15:30
**状态**: ✅ 特殊攻击架构优化完成
**本次会话完成**：
1. ✅ 修复敌人乱动问题（StunState 物理模拟优化）
2. ✅ 修复聚集范围受限问题（架构重构）
3. ✅ Token 消耗优化（-86.7% 日志输出）
4. ✅ 开发日志和优化报告编写

**下次重点**: 测试 V 技能在多敌人场景下的表现，验证聚集范围优化
